## GNU General Public License
## 
## Program pyNastran - a python interface to NASTRAN files
## Copyright (C) 2011  Steven Doyle
## 
## Author and copyright holder of pyMastran
## Steven Doyle <mesheb82@gmail.com>
## 
## This file is part of pyNastran.
## 
## pyNastran is free software: you can redistribute it and/or modify
## it under the terms of the GNU Lesser General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## pyNastran is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU Lesser General Public License
## along with pyNastran.  If not, see <http://www.gnu.org/licenses/>.
## 
## This header is automatically generated by applyLicense.py and any
## changes to it will be lost.
## 
import os
import sys
import inspect

class debugLogger(object):
    def __init__(self):
        pass

    #def frame(self): # good...
    #    return inspect.currentframe()

    def frame(self):
       #print help(inspect)
       return inspect.currentframe(4) # jump 4 levels down to get out of the logger code


    def lineno(self):
        """Returns the current line number in our program."""
        return self.frame().f_lineno

    def fname(self):
        """Returns the current file in our program."""
        return os.path.basename(self.frame().f_globals['__file__'])

    def funcName(self):
        """Returns the current function name in our program."""
        #print inspect.currentframe().f_back.f_back.f_locals['self']
        #print self.frame().f_globals.keys()
        #print self.frame().f_locals.keys()

        #return os.path.basename(self.frame().f_globals['__name__'])
        #return self.frame().__file__
        pass

    def properties(self):
        n = self.lineno()
        fname = self.fname()
        #funcName = self.funcName()
        funcName = ''
        return (n,fname,funcName)

    def fixMessage(self,msg,n=54):
        msg = str(msg)
        #print "msg = |%s| type=%s" %(msg,type(msg))
        lines = msg.split('\n')
        lines2 = [lines[0]]

        spaces = ' '*n
        #print "lines = ",lines
        for line in lines[1:]:
            lines2.append(spaces+line+'\n')
        msg2 = ''.join(lines2)
        return msg2

    def debug(self,msg):
        (n,fname,funcName) = self.properties()
        msg = self.fixMessage(msg)
        sys.stdout.write('DEBUG:   fname=%-25s lineNo=%-4s   %s\n' %(fname,n,msg))

    def info(self,msg):
        (n,fname,funcName) = self.properties()
        sys.stdout.write('INFO:    fname=%-25s lineNo=%-4s   %s\n' %(fname,n,msg))

    def warning(self,msg):
        (n,fname,funcName) = self.properties()
        sys.stderr.write('WARNING: fname=%-25s lineNo=%-4s   %s\n' %(fname,n,msg))

    def error(self,msg):
        (n,fname,funcName) = self.properties()
        print 'ERROR:   fname=%-25s lineNo=%-4s   %s\n' %(fname,n,msg)

    def critical(self,msg):
        (n,fname,funcName) = self.properties()
        sys.stderr.write('CRITICAL fname=%-25s lineNo=%-4s   %s\n' %(fname,n,msg))
    ###

class infoLogger(debugLogger):
    def debug(self,msg):
        pass

class dummyLogger(object):
    def __init__(self):
        pass

    def startLog(self,level):
        if level=='debug':
            return debugLogger()
        elif level=='info':
            return infoLogger()
        else:
            raise Exception("invalid logger:  debug, info ONLY!")

def getLogger(log=None,level='debug'):
    """
    This function is useful as it will instantiate a dummy logger object if log=None
    log may be a logger object or None
    pyFile is the python file that the code was called from (unused)
    """
    if log==None:
        log = dummyLogger()
        logger = log.startLog(level)
    else:
        logger = log
    return logger

if __name__=='__main__':
    # how to use a dummy logger
    logger = dummyLogger()
    log = logger.startLog('debug') # or info
    log.debug('test message')

