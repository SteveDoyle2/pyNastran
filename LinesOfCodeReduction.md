# Introduction #

The current development version of pyNastran has 52k lines of code spanning 222 files. Reducing this by 10% would help tremendously.
One of the ways to achieve this goal in the more extensive usage of Python idioms and Python standard library.


# Preparations #

First part of this project is all about learning. For Python coding standards and coding tips I found these websites particularly interesting:

  * [Idioms and Anti-Idioms in Python](http://docs.python.org/howto/doanddont.html)
  * [PEP 8 -- Style Guide for Python Code](http://www.python.org/dev/peps/pep-0008/)
  * [PEP 257 -- Docstring Conventions](http://www.python.org/dev/peps/pep-0257/)
  * [Intermediate and Advanced Software Carpentry in Python](http://ivory.idyll.org/articles/advanced-swc/)
  * [Code Like a Pythonista: Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)
  * [Python Idioms and Efficiency](http://www.memonic.com/user/pneff/folder/python/id/1bufp)
  * [Stop Writing Classes ](http://www.youtube.com/watch?v=o9pEzgHorH0)


# Testing #

Most of the time it will be necessary to refactor existing code. Therefore it is especially important to make sure that the changes will not break existing code. This is the place where Python [unittest](http://docs.python.org/library/unittest.html) module comes in. For changed code new tests will be written and existing ones will be used extensively.


The general idea is to create automatic system that will check the project against different versions of Python after code change.


# Documentation #


Documentation is extremely important in understanding new code.

## Doxygen ##

pyNastran have very nice documentation, prepared to render in HTML form with [Doxygen](http://www.doxygen.org). In order to better understand class structure of a project it is useful to enable [Graphviz](http://http://www.graphviz.org/) usage (with `HAVE_DOT = YES` in `Doxyfile`). Doxygen can use _dot_ program to generate different graphs:

```

CLASS_GRAPH         = YES # direct and indirect inheritance relations for each documented class

COLLABORATION_GRAPH = YES #direct and indirect implementation dependencies for each documented class

INCLUDE_GRAPH       = YES # graph for each documented file showing the direct and indirect include dependencies

CALL_GRAPH          = YES  #dependency graph for every global function or class method

CALLER_GRAPH        = YES #caller dependency graph for every global function or class method

GRAPHICAL_HIERARCHY = YES #doxygen will generate a graphical hierarchy of all classes instead of a textual one

```

_**Warning**_ Enabling all of this options makes documentation building significantly longer and documentation itself gets **much** bigger (almost 4GB for revision [r1040](https://code.google.com/p/pynastran/source/detail?r=1040))


## Sphinx ##

Currently, most of python programs (and Python itself) are documented with a help of [Sphinx](http://sphinx.pocoo.org). Sphinx can generate a lot of different output formats (including latex, pdf and epub) and of course HTML. Some people like better the HTML documentation generated by Sphinx more and consider it more clear. Sphinx uses [reStructuredText](http://http://docutils.sourceforge.net/rst.html) (reST) as a markup language. The comparison of most useful keywords in Sphinx  and Doxygen is as follow


| Doxygen |  Sphinx |
|:--------|:--------|
| `@param parameter` | `:param parameter:` |
| `@retval` | `:returns:` |
| `@raise` | `:raises:` |
| `@note` | `.. note::` |
| `@warning` | `.. warning::` |
| `@deprecated` | `.. deprecated::` |
| `@todo` | `.. todo::` |


To generate HTML documentation using Sphinx it is necessary to go to `docs_sphinx` directory and issue `make html` command. The conversion form Doxygen documentation format will be automatic. Code responsible for it has been added to `conf.py` configuration file and it seems that it works quite well.

### User and developer documentation ###

User and developer documentation (currently in Latex format) will also be available through Sphinx. Therefore it will be easy to read documentation using web browser and use hyper links to easily find documentation of particular class and  methods.

Most of the documentation present in `pyNastran/docs` in the LaTeX format has been ported to Sphinx. Now it is possible to easily read the manual in the HTML form. Moreover the class and methods mentioned in the manual are linked directly to their documentation.

### PDF and epub documentation format ###

Sphinx makes generating PDF and epub files easy. The PDF documentation is generated with the command

```
make latexpdf 
```

It contains the manual and API documentation in nice book form. All links (to WWW websites and internal links within documentation) works as in the HTML version.

It is possible to create ereaders friendly ePub file with the command

```
make epub 
```

Unforunately, currently it does not support mathematics equations correctly. Nevertheless the resulting file is usable to read the manual part of the documentation.

## Mathematics with Latex ##

Both Doxygen and Sphinx 'understand' LaTeX code and nicely generate mathematics formulas. **There is one very important note**: you have to remember about escape characters. Every documentation comment in Python is just a string. Therefore Python will understand

`""" \thau """`

as

`   hau`

that is 'TABULATORhau', and not "\thau". The easiest solution is to mark every string containing LaTeX code as a **raw** string: `r""" \thau """`.

## Documentation summary ##

Currently the sphinx documentation is considered usable and no big changes in documentation handling are planned.

# Code refactoring #

It is necessary to modify project code in order to simplify package structure.

## Exceptions ##

All of the custom Exceptions have been removed. Python defines many default Exception types and they should be sufficient for current needs. The following table presents pattern of the replace:

| **Defined in file** |  **Definition of custom error**               | **Replaced with**                                |
|:--------------------|:----------------------------------------------|:-------------------------------------------------|
|bdf/errors.py      | CardParseError(SyntaxError) 	             | _removed_                                      |
|bdf/errors.py      | ParamParseError(CardParseError)            | SyntaxError("Param Parse: %msg%")             |
|bdf/errors.py      | ScientificCardParseError(CardParseError)   | _removed_                                      |
|bdf/errors.py      | CardInstantiationError(RuntimeError)       | RuntimeError("Card Instantiation: %msg%")     |
|bdf/errors.py      | InvalidSubcaseParseError(SyntaxError)      | SyntaxError("Invalid Subcase: %msg%")         |
|op2/op2Errors.py   | InvalidCodeError(RuntimeError)             | RuntimeError("Invalid Code: %msg%")           |
|op2/op2Errors.py   | !InvalidGridID\_Error(ValueError)            | ValueError("Invalid Grid ID: %msg%")          |
|op2/op2Errors.py   | TapeCodeError(InvalidCodeError)            | RuntimeError("Tape Code Error: %msg%")        |
|op2/op2Errors.py   | EndOfFileError(RuntimeError)               | EOFError                                      |
|op2/op2Errors.py   | InvalidAnalysisCodeError(InvalidCodeError) | RuntimeError('Invalid Analysis Code:  %msg%") |
|op2/op2Errors.py   | !InvalidATFSCodeError(InvalidCodeError)     | _removed_                                      |
|op2/op2Errors.py   | ZeroBufferError(RuntimeError)              | RuntimeError('Zero Buffer Error')             |
|op2/op2Errors.py   | InvalidMarkersError(RuntimeError)          | SyntaxError("Invalid Markers: %msg%")         |
|op2/op2Errors.py   | InvalidMarkerError(RuntimeError)           | SyntaxError("Invalid Marker: %msg%")          |
|f06/f06.py         | EndOfFileError(!Exception)                  | _removed_                                      |


## Module general ##

Module general will be refactored in order to simplify its usage and code developing.
Most frequently used functions (list\_print?) will be moved to the `__init__.py` file This will
allow to replace the calls

```
from pyNastran.general.general import ...
```

into

```
from pyNastran.general import ...
```

This could be obtained in pyNastran by simply adding `from general import *` to `__init__.py`.
Some programmers suggest not to add **function/class** implementation code `__init__.py` file and keep additional
`.py` file inside a package. **But this would add additional layer between code callers and the code implementation** thus
make code less clear. Every package in python is also a module, with an implementation code in `__init__.py` file.
Therefore the code will be moved to `__init__.py`. Similar code placement is used, for example. in [Django](https://www.djangoproject.com/).

Mathematical related functions will be moved to `mathematics.py` module and most of the rest into `utils.py` module.

**Status**

  * generalMath and matrixMethods are merged into mathematics module. Gauss function is know fully functional and documented. Functions are simplified, but more documentation would be useful.
  * generaMath -> some functions that were used only in shell.py has been moved to shell.py.
  * object\_introstpection module is moved to utils.py functions are more flexible and documented. Functions test have been updated to match new capabilities. Tests are working properly in Python 2 and 3 (some properties of objets changed between versions and test has to take it into account).
  * refactor almost complete, some bugs have been fixed and tests added.

**Final status**

The module has been refactored. Name of the module has been changed to **utils** as it better suits its purpose. The code from `utils.py` has been moved to `__init__.py` file. Usage pattern is now as follows

```
from pyNastran.utils import is_binary
```

instead of

```
from pyNastran.general.general import is_binary
```



**Log**

A `dummyLogger` has been refactored into a `simpleLogger` class (file `pyNastran/utils/log.py`). It understands that **debug** messages should be displayed only in the `debug` mode. Therefore, now instead of:

```
if self.debug:
    self.log.debug("debug message")
```

it is enough to write

```
self.log.debug("debug message")
```


## applyLicense.py and build\_2to3.py ##

Files `applyLicense.py` and `build_2to3.py` have been refactored. It took surprisingly long time, but the code inside the files is now much shorter and clearer. Codebase converted to Python 3 seems to work correctly. Nevertheless, it still may contain bugs.

**Important note:** Python 2.7 has a module `io` providing the Python interfaces to stream handling (files handling) that is the default interface in Python 3.x. It may be a good idea to use it as a default in a new code as it provides identical behaviour between Python versions. The `build_2to3.py` adds `encoding='utf-8'` parameter to `open()` function but it does not change anything if a word `open` is preceded by a dot (as in `io.open()`).

## Notable code changes ##

  * Method `get_next_line` has been moved from `bdf_Reader` to `bdf_CardMethods` as it requires `bdf_CardMethods_make_lines_pack` method
  * `BDF.readBDF_Punch()` has been merged into `BDF.readBDF_Punch()`. New parameter `punch` has been added to `BDF.readBDF_Punch()` and `BDF.readBDF_Punch(punch=True)` is equal to old `BDF.readBDF_Punch()`.
  * Some methods of `BDF` class has been refactored. Most importantly: the `add_card` method. The `bdf.py` has 1295 lines instead of 2129. _**Warning**_: `add_card` method heavily uses Python introspection and asks for some classes at the runtime. pylint gives warnings about unused classes that can be safely ignored (pylint does not know anything about runtime environment of a program).
  * A lot of methods in the `addCard.py` has been renamed. They are more consistent and readable. Methods specialized for supporting one specyfic type of a card have names beginning with `add_` and then the card name, e.g.

```
def add_CAERO(self, caero)
def add_DCONSTR(self, dconstr)
```

Methods names are in accordance with the PEP-8 guidelines (they are not strictly PEP-8 names but PEP-8 says that rules should be broken if 'applying the rule would make the code less readable' and names with card names in upper-case are most readable).

## GUI in PyQT ##

A new GUI written in the PyQT toolkit has been added to the project. It looks very similar to the existing one (created with wxWidgets)

![https://pynastran.googlecode.com/svn/branches/locr_2012/pyNastran/gui_qt/demoqtgui.png](https://pynastran.googlecode.com/svn/branches/locr_2012/pyNastran/gui_qt/demoqtgui.png)

Thanks to refactored logging facilities the new GUI can display application logs directly. By default it displays DEBUG messages in "Crimson" (red) and its own messages in blue. Logging widget can be moved around inside application.

![https://pynastran.googlecode.com/svn/branches/locr_2012/pyNastran/gui_qt/demoqtgui2.png](https://pynastran.googlecode.com/svn/branches/locr_2012/pyNastran/gui_qt/demoqtgui2.png)

Toolbar and log widget ca be hidden. Moreover, user settings are saved at the application close and restored when started again.

The GUI works stable, but should be considered experimental as it does not have all of the functionality of the wxWidgets GUI.

# Project code #

Project code can be accessed in the [locr\_2012](http://code.google.com/p/pynastran/source/browse/#svn%2Fbranches%2Flocr_2012) SVN branch.