#summary Summary of project aiming to reduce size of pyNastran codebase

= Introduction =

The current development version of pyNastran has 52k lines of code spanning 222 files. Reducing this by 10% would help tremendously.
One of the ways to achieve this goal in the more extensive usage of Python idioms and Python standard library.


= Preparations =

First part of this project is all about learning. For Python coding standards and coding tips I found these websites particularly interesting:

 * [http://docs.python.org/howto/doanddont.html Idioms and Anti-Idioms in Python]
 * [http://www.python.org/dev/peps/pep-0008/ PEP 8 -- Style Guide for Python Code]
 * [http://www.python.org/dev/peps/pep-0257/ PEP 257 -- Docstring Conventions]
 * [http://ivory.idyll.org/articles/advanced-swc/ Intermediate and Advanced Software Carpentry in Python]
 * [http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html Code Like a Pythonista: Idiomatic Python]
 * [http://www.memonic.com/user/pneff/folder/python/id/1bufp Python Idioms and Efficiency]
 * [http://www.youtube.com/watch?v=o9pEzgHorH0 Stop Writing Classes ]


= Testing =

Most of the time it will be necessary to refactor existing code. Therefore it is especially important to make sure that the changes will not break existing code. This is the place where Python [http://docs.python.org/library/unittest.html unittest] module comes in. For changed code new tests will be written and existing ones will be used extensively.
 

The general idea is to create automatic system that will check the project against different versions of Python after code change.


= Documentation =


Documentation is extremely important in understanding new code. 

== Doxygen ==

pyNastran have very nice documentation, prepared to render in HTML form with [http://www.doxygen.org Doxygen]. In order to better understand class structure of a project it is useful to enable [http://http://www.graphviz.org/ Graphviz] usage (with `HAVE_DOT = YES` in `Doxyfile`). Doxygen can use _dot_ program to generate different graphs:

{{{

CLASS_GRAPH         = YES # direct and indirect inheritance relations for each documented class

COLLABORATION_GRAPH = YES #direct and indirect implementation dependencies for each documented class

INCLUDE_GRAPH       = YES # graph for each documented file showing the direct and indirect include dependencies

CALL_GRAPH          = YES  #dependency graph for every global function or class method

CALLER_GRAPH        = YES #caller dependency graph for every global function or class method

GRAPHICAL_HIERARCHY = YES #doxygen will generate a graphical hierarchy of all classes instead of a textual one

}}}

_*Warning*_ Enabling all of this options makes documentation building significantly longer and documentation itself gets *much* bigger (almost 4GB for revision r1040)


== Sphinx ==

Currently, most of python programs (and Python itself) are documented with a help of [http://sphinx.pocoo.org Sphinx]. Sphinx can generate a lot of different output formats (including latex, pdf and epub) and of course HTML. Some people like better the HTML documentation generated by Sphinx more and consider it more clear. Sphinx uses [http://http://docutils.sourceforge.net/rst.html reStructuredText] (reST) as a markup language. The comparison of most useful keywords in Sphinx  and Doxygen is as follow


|| Doxygen ||  Sphinx ||
|| `@param parameter` || `:param parameter:` ||
|| `@retval` || `:returns:` ||
|| `@raise` || `:raises:` ||
|| `@note` || `.. note::` ||
|| `@warning` || `.. warning::` ||
|| `@deprecated` || `.. deprecated::` ||
|| `@todo` || `.. todo::` ||


To generate HTML documentation using Sphinx it is necessary to go to `docs_sphinx` directory and issue `make html` command. The conversion form Doxygen documentation format will be automatic. Code responsible for it has been added to `conf.py` configuration file and it seems that it works quite well.

=== User and developer documentation ===

User and developer documentation (currently in Latex format) will also be available through Sphinx. Therefore it will be easy to read documentation using web browser and use hyper links to easily find documentation of particular class and  methods.

Most of the documentation present in `pyNastran/docs` in the LaTeX format has been ported to Sphinx. Now it is possible to easily read the manual in the HTML form. Moreover the class and methods mentioned in the manual are linked directly to their documentation.

=== PDF and epub documentation format ===

Sphinx makes generating PDF and epub files easy. The PDF documentation is generated with the command

{{{ 
make latexpdf 
}}}

It contains the manual and API documentation in nice book form. All links (to WWW websites and internal links within documentation) works as in the HTML version. 

It is possible to create ereaders friendly ePub file with the command

{{{ 
make epub 
}}}

Unforunately, currently it does not support mathematics equations correctly. Nevertheless the resulting file is usable to read the manual part of the documentation.

== Mathematics with Latex ==

Both Doxygen and Sphinx 'understand' LaTeX code and nicely generate mathematics formulas. *There is one very important note*: you have to remember about escape characters. Every documentation comment in Python is just a string. Therefore Python will understand 

{{{""" \thau """}}}

as

{{{   hau}}}

that is 'TABULATORhau', and not "\thau". The easiest solution is to mark every string containing LaTeX code as a *raw* string: `r""" \thau """`.

== Documentation summary ==

Currently the sphinx documentation is considered usable and no big changes in documentation handling are planned.

= Code refactoring = 

It is necessary to modify project code in order to simplify package structure.

== Exceptions ==

All of the custom Exceptions have been removed. Python defines many default Exception types and they should be sufficient for current needs. The following table presents pattern of the replace:

|| *Defined in file* ||  *Definition of custom error *               || *Replaced with*                                ||
||bdf/errors.py      || !CardParseError(!SyntaxError) 	             || _removed_                                      ||
||bdf/errors.py      || !ParamParseError(!CardParseError)            || !SyntaxError("Param Parse: %msg%")             ||
||bdf/errors.py      || !ScientificCardParseError(!CardParseError)   || _removed_                                      ||
||bdf/errors.py      || !CardInstantiationError(!RuntimeError)       || !RuntimeError("Card Instantiation: %msg%")     ||
||bdf/errors.py      || !InvalidSubcaseParseError(!SyntaxError)      || !SyntaxError("Invalid Subcase: %msg%")         ||
||op2/op2Errors.py   || !InvalidCodeError(!RuntimeError)             || !RuntimeError("Invalid Code: %msg%")           ||
||op2/op2Errors.py   || !InvalidGridID_Error(!ValueError)            || !ValueError("Invalid Grid ID: %msg%")          ||
||op2/op2Errors.py   || !TapeCodeError(!InvalidCodeError)            || !RuntimeError("Tape Code Error: %msg%")        ||
||op2/op2Errors.py   || !EndOfFileError(!RuntimeError)               || EOFError                                      ||
||op2/op2Errors.py   || !InvalidAnalysisCodeError(!InvalidCodeError) || !RuntimeError('Invalid Analysis Code:  %msg%") ||
||op2/op2Errors.py   || !InvalidATFSCodeError(!InvalidCodeError)     || _removed_                                      ||
||op2/op2Errors.py   || !ZeroBufferError(!RuntimeError)              || !RuntimeError('Zero Buffer Error')             ||
||op2/op2Errors.py   || !InvalidMarkersError(!RuntimeError)          || !SyntaxError("Invalid Markers: %msg%")         ||
||op2/op2Errors.py   || !InvalidMarkerError(!RuntimeError)           || !SyntaxError("Invalid Marker: %msg%")          ||
||f06/f06.py         || !EndOfFileError(!Exception)                  || _removed_                                      ||


== Module general == 

Module general will be refactored in order to simplify its usage and code developing.
Most frequently used functions will be moved to the `__init__.py` file This will
allow to replace the calls

{{{
from pyNastran.general.general import ...
}}}

into 

{{{
from pyNastran.general import ...
}}}

This could be obtained in pyNastran by simply adding `from general import *` to `__init__.py`.
Some programmers suggest not to add *function/class* implementation code `__init__.py` file and keep additional 
`.py` file inside a package. **But this would add additional layer between code callers and implementation** thus
make code less clear. Every package in python is also a module, with an implementation code in `__init__.py` file.
Therefore the code will be moved to `__init__.py`. Similar code placement is used, for example. in [https://www.djangoproject.com/ Django]. 

Mathematical related functions will be moved to `math.py` module and most of the rest into `utils.py` module.

= Project code =

New code will be maintained in [http://code.google.com/p/pynastran/source/browse/#svn%2Fbranches%2Flocr_2012 locr_2012] SVN branch.